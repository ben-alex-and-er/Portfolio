namespace Portfolio.Pages
{
	/// <summary>
	/// Represents a common code object
	/// </summary>
	public partial class CommonCode
	{
		private const string nugetDeployCode = "name: Nuget Deploy\r\non:\r\n  push:\r\n    branches:\r\n      - main\r\n  pull_request:\r\n    types: [opened, synchronize, reopened]\r\njobs:\r\n  build:\r\n    name: Build, Pack and Deploy\r\n    runs-on: windows-latest\r\n    steps:\r\n      - name: Checkout\r\n        uses: actions/checkout@v4\r\n\r\n      - name: Restore dependencies\r\n        run: dotnet restore CommonCode/CommonCode.sln\r\n\r\n      - name: Build projects\r\n        run: dotnet build CommonCode/CommonCode.sln --configuration Release\r\n\r\n      - name: Pack all projects\r\n        run: dotnet pack CommonCode/CommonCode.sln --configuration Release --no-build -o ./artifacts\r\n\r\n      - name: Push packages to NuGet\r\n        run: .github\\scripts\\push-packages.cmd\r\n        shell: cmd\r\n        env:\r\n          NUGET_TOKEN: ${{ secrets.NUGET_TOKEN }}";

		private const string passwordHasherCode = "using System.Security.Cryptography;\r\n\r\n\r\nnamespace GateKeeper.Cryptography\r\n{\r\n\t/// <summary>\r\n\t/// Manager for hashing and verifying passwords\r\n\t/// </summary>\r\n\tpublic static class PasswordHasher\r\n\t{\r\n\t\tprivate const int SALT_SIZE = 16;\r\n\t\tprivate const int HASH_SIZE = 32;\r\n\t\tprivate const int ITERATIONS = 100000;\r\n\r\n\r\n\t\tprivate static readonly HashAlgorithmName HashAlgorithm = HashAlgorithmName.SHA512;\r\n\r\n\r\n\t\t/// <summary>\r\n\t\t/// Converts a password to a <see cref=\"HashedPassword\"/>\r\n\t\t/// </summary>\r\n\t\t/// <param name=\"password\">Password to hash</param>\r\n\t\t/// <returns>Hashed password</returns>\r\n\t\tpublic static HashedPassword HashPassword(\r\n\t\t\tstring password,\r\n\t\t\tHashAlgorithmName algorithm,\r\n\t\t\tint saltSize = SALT_SIZE,\r\n\t\t\tint hashSize = HASH_SIZE,\r\n\t\t\tint iterations = ITERATIONS)\r\n\t\t{\r\n\t\t\tvar salt = RandomNumberGenerator.GetBytes(saltSize);\r\n\r\n\t\t\tvar hash = Rfc2898DeriveBytes.Pbkdf2(password, salt, iterations, algorithm, hashSize);\r\n\r\n\t\t\treturn new(salt, iterations, algorithm, hashSize, hash);\r\n\t\t}\r\n\r\n\t\t/// <summary>\r\n\t\t/// Converts a password to a <see cref=\"HashedPassword\"/> with a suggested <see cref=\"HashAlgorithmName\"/>\r\n\t\t/// </summary>\r\n\t\t/// <param name=\"password\">Password to hash</param>\r\n\t\t/// <returns>Hashed password</returns>\r\n\t\tpublic static HashedPassword HashPassword(\r\n\t\t\tstring password,\r\n\t\t\tint saltSize = SALT_SIZE,\r\n\t\t\tint hashSize = HASH_SIZE,\r\n\t\t\tint iterations = ITERATIONS)\r\n\t\t\t=> HashPassword(password, HashAlgorithm, saltSize, hashSize, iterations);\r\n\r\n\t\t/// <summary>\r\n\t\t/// Verified that the entered password is eqivalent to the HashedPassword\r\n\t\t/// </summary>\r\n\t\t/// <param name=\"password\"></param>\r\n\t\t/// <param name=\"storedHash\"></param>\r\n\t\t/// <returns></returns>\r\n\t\tpublic static bool VerifyPassword(string password, HashedPassword storedHash)\r\n\t\t{\r\n\t\t\tvar salt = Convert.FromBase64String(storedHash.Salt);\r\n\t\t\tvar iterations = storedHash.Iterations;\r\n\t\t\tvar algorithm = storedHash.Algorithm;\r\n\t\t\tvar hashSize = storedHash.HashSize;\r\n\r\n\t\t\tvar newHashBytes = Rfc2898DeriveBytes.Pbkdf2(password, salt, iterations, algorithm, hashSize);\r\n\r\n\t\t\tvar newHash = Convert.ToBase64String(newHashBytes);\r\n\r\n\t\t\treturn newHash.Equals(storedHash.Hash);\r\n\t\t}\r\n\t}\r\n}\r\n";

		private const string sonarCodeCoverageCode = "name: SonarQube\r\non:\r\n  push:\r\n    branches:\r\n      - main\r\n  pull_request:\r\n    types: [opened, synchronize, reopened]\r\njobs:\r\n  build:\r\n    name: Build and analyze\r\n    runs-on: windows-latest\r\n    steps:\r\n      - name: Set up JDK 17\r\n        uses: actions/setup-java@v4\r\n        with:\r\n          java-version: 17\r\n          distribution: 'zulu' # Alternative distribution options are available.\r\n      - uses: actions/checkout@v4\r\n        with:\r\n          fetch-depth: 0  # Shallow clones should be disabled for a better relevancy of analysis\r\n          \r\n      - name: Cache SonarQube Cloud packages\r\n        uses: actions/cache@v4\r\n        with:\r\n          path: ~\\sonar\\cache\r\n          key: ${{ runner.os }}-sonar\r\n          restore-keys: ${{ runner.os }}-sonar\r\n\r\n      - name: Cache SonarQube Cloud scanner\r\n        id: cache-sonar-scanner\r\n        uses: actions/cache@v4\r\n        with:\r\n          path: .\\.sonar\\scanner\r\n          key: ${{ runner.os }}-sonar-scanner\r\n          restore-keys: ${{ runner.os }}-sonar-scanner\r\n\r\n      - name: Install SonarQube Cloud scanner\r\n        if: steps.cache-sonar-scanner.outputs.cache-hit != 'true'\r\n        shell: powershell\r\n        run: |\r\n          New-Item -Path .\\.sonar\\scanner -ItemType Directory\r\n          dotnet tool update dotnet-sonarscanner --tool-path .\\.sonar\\scanner\r\n\r\n      - name: Install .NET Coverage\r\n        run: dotnet tool install --global dotnet-coverage\r\n\r\n      - name: Build and analyze\r\n        env:\r\n          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}\r\n        shell: powershell\r\n        run: |\r\n          .\\.sonar\\scanner\\dotnet-sonarscanner begin `\r\n            /k:\"ben-alex-and-er_CommonCode\" `\r\n            /o:\"ben-alex-and-er\" `\r\n            /d:sonar.token=\"$env:SONAR_TOKEN\" `\r\n            /d:sonar.cs.vscoveragexml.reportsPaths=coverage.xml `\r\n            /d:sonar.exclusions=\"Unit Tests/**\"\r\n          dotnet build CommonCode/CommonCode.sln --no-incremental\r\n          dotnet-coverage collect \"dotnet test CommonCode/CommonCode.sln\" -f xml -o \"coverage.xml\"\r\n          .\\.sonar\\scanner\\dotnet-sonarscanner end /d:sonar.token=\"$env:SONAR_TOKEN\"";
	}
}